Golang OOPs Concepts
26 July 2019
Tags: go golang oops concepts

Poonam Malve

* Agenda
- Introduction to OOPs
- Object-Oriented Language Features
- Object-Oriented Design: The Go Way


* Introduction to OOPs
  OOP based on the definition:
- Is a programming paradigm based on the concept of “objects”, which may contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods
- an Object’s procedures can access and often modify the attributes of the object with which they are associated
- an Object’s internal state is protected from outside world (encapsulated) leveraging private/protected/public visibility of attributes and methods
- an Object is frequently defined in OO languages as an instance of a Class
- The most striking omission as far as object-oriented is concerned is that there is no type hierarchy in Go.
Contd..

* Introduction to OOPs (Contd..)
  The mentioned concept properties are implemented in most popular OO languages, Java and C++ 
  by mechanics such as:
- Encapsulation (possible on package level in Go)
- Composition (possible through embedding in Go)
- Polymorphism (possible through Interface satisfaction in Go. Type satisfies Interface without manually implementing it if it defines all the Interface methods. Since almost anything can have methods attached, even primitive types such as Int, almost anything can satisfy an interface)
- Inheritance (Go does not provide the typical, type-driven notion of subclassing because it’s fragile and considered a bad practice, inferior to Composition)

* Go Object-Oriented Language Features
- Structs
- Methods
- Embedding
- Interfaces

* 1. Structs:

- A struct defines state. Here is a Student struct. 
- It has a Name field and a integer called ID, which tells us if student got his/her Student ID. 
- Structs hold only state and no behavior.

     type Student struct {
     Name string
     ID int
     }

* 2. Methods:

- Methods are functions that operate on particular types. 
- They have a receiver clause that mandates what type they operate on. 
- Here is a GetData() method that operates on Student structs and prints their state:

      func (s Student) GetData() {
          fmt.Printf("Name: '%s', ID: %d\n", s.Name, s.ID)
      }
          
* 3. Embedding:

- You can embed anonymous types inside each other. 
- If you embed a nameless struct then the embedded struct provides its state (and methods) to the embedding struct directly. 
- Here is example
.code embeddingtypedemo/main.go /^//Part 1/,/^//Part 2/

* 3. Embedding: (Contd..)
.play embeddingtypedemo/main.go /^//Part 2/,/^//END/

- The main purpose of type embedding is to extend the functionalities of the embedded types into the embedding type, so that we don't need to re-implement the functionalities of the embedded types for the embedding type.


* 4. Interface:
- Go isn’t object oriented in the typical sense, i.e. if you’re coming from C#, Java or even C++, but it does offer some features which map to features often available in the OO world in one way or another.
- It does not have exact Inheritance but duck typing. 
.link https://en.wikipedia.org/wiki/Duck_typing Read more about Duck typing here
- Duck typing comes from the phrase – if something looks like a duck, swims like a duck and quacks like a duck then it’s probably a duck.

* Implementation:
.code interfacedemo/main.go /^//Part 1/,/^//Part 2/
Contd..

* Implementation (Contd..):
.play interfacedemo/main.go /^//Part 2/,/^//END/

* Object-Oriented Design: The Go Way
- Let's see how Go measures up against the pillars of object-oriented programming: encapsulation, inheritance, and polymorphism. 
- Those are features of class-based programming languages, which are the most popular object-oriented programming languages.
- At the core, objects are language constructs that have state and behavior that operates on the state and selectively exposes it to other parts of the program. 

* 1. Encapsulation:
- A variable or method of an object is said to be encapsulated if it is inaccessible to clients of the object. 
- Encapsulation, sometimes called information hiding, is a key aspect of object-oriented programming.
- Go has only one mechanism to control the visibility of names: capitalized identifiers are exported from the package in which they are defined, and uncapitalized names are not. 
- The same mechanism that limits access to members of a package also limits access to the fields of a struct or the methods of a type. As a consequence, to encapsulate an object, we must make it a struct.

* 1. Encapsulation (Contd..)
- Let's take an example:
.code goencapsulation/realestate/Property.go
.code goencapsulation/realestate/Building.go
.code goencapsulation/realestate/House.go


* Strings in Go

Strings are UTF-8 encoded 
.play string/stringEncoding/main.go /^func main/,/^}/
: Presenter notes (first paragraph)

* Strings cont...
.play string/stringUnicode/main.go /^func main/,/^}/

* Rune
.play string/rune/main.go /^func main/,/^}/

* Rune cont...
.play string/runeIteration/main.go /^func main/,/^}/
Any valid UTF-8 character within a single quote (') is a rune and it’s type is int32.
.play string/runeValue/main.go /^func main/,/^}/

* Strings are immutable
If we try to replace any byte in the slice, the compiler will throw an error.
.play string/stringImmutable/main.go /^func main/,/^}/

* String Functions
.play string/stringFunction/main.go /^var p/,/^}/

* Struct
A structure has different fields of the same or different type.  A struct is used mainly when you need to define a schema type made of different individual fields (properties). Like ross is a type of Employee (struct) which has firstName, LastName, salary and fullTime status (schema fields).

In following example, Employee is struct type while ross is struct, while struct is a built-in type.    
.play struct/createStruct/main.go
Employee is struct type while ross is struct, while struct is a built-in type.  

* Struct Fields
When a struct is defined, using . (dot) notation, you can access struct fields with syntax struct.field.
.play struct/accessFields/main.go /^func main/,/^}/

Initialize struct
.play struct/initializeStruct/main.go /^func main/,/^}/

* Anonymous struct
An anonymous struct is a struct with no explicitly defined struct type alias. This is useful when you don’t want to re-use a struct type.

.play struct/anonymousStruct/main.go /^func main/,/^}/

* Pointer to struct
Instead of creating a struct, we can create a pointer which points to the struct in one statement. This saves one step to create a struct (variable) and then create a pointer to that variable.
.play struct/pointer/main.go /^func main/,/^}/

In the above program, since ross is a pointer, we need to use *ross to get actual value and use (*ross).firstName to access firstName so that compiler doesn’t get confused between (*ross).firstName and *(ross.firstName). But Go provide another syntax to access fields like in case of array pointer. Without using *, we can use directly pointer to access fields.

* Nested Struct and Anonymous Field
.play struct/nestedStruct/main.go /^type/,/^//End/

* Functions as Struct fields
Struct fields can also be functions.
.play struct/functionFields/main.go /^type/,/^//End/

* Comparing structs
Two structs are comparable if they belong to the same type and have the same field values. If a struct has field type which is not comparable, for example, map which is not comparable, then the struct won’t be comparable. 
.play struct/compareStruct/main.go /^func main/,/^//End/

* Methods with struct
#A method is nothing but a function, but it belongs to a certain type. 
.play struct/method/main.go /^type/,/^} //End/

* Meta data
Used to provide transformation info on how a struct field is encoded to or decoded from another format (or stored/retrieved from a database)

 type Employee struct {
 	firstName string `json:"firstName"`
 	lastName  string `json:"lastName"`
 	salary    int    `json: "salary"`
 	fullTime  int    `json: "fullTime"`
 }

* Panic
.play deferpanicrecover/panicFunc/main.go

* Panic cont..
When a panic occurs, no further statements are executed and Go starts unwinding the stack by calling each pending statement in the stack until the last statement which was called from the main function.

The panic function can receive any type of argument as its signature looks like below, and we know an empty interface type represents all the values.

 panic(interface{})

* Defer
.play deferpanicrecover/defer/main.go /^func/,/^} //End/

* Recover
.play deferpanicrecover/recover/main.go

* Recover cont...
.play deferpanicrecover/recoverFail/main.go /^func/,/^} //End/

* Recover cont...
.play deferpanicrecover/returnValueFromRecover/main.go /^func/,/^} //End/

* Timer	
.play timer/main.go /^func main/,/^}/

* Ticker	
.play ticker/main.go /^func main/,/^}/

* Reference
.link https://medium.com/rungo/go-introductory-tutorials-896aeda0fb8a
.link https://gobyexample.com/







 





